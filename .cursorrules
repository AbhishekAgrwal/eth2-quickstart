# Ethereum Node Setup - Agent Context

## Documentation Structure
This project contains comprehensive documentation organized in the `docs/` folder:

### Core Documentation
- `docs/README.md` - Main project overview and quickstart guide
- `docs/SCRIPTS.md` - Detailed script reference and usage
- `docs/WORKFLOW.md` - Setup workflow and process documentation
- `docs/GLOSSARY.md` - Technical terminology and definitions

### Configuration & Architecture
- `docs/CONFIGURATION_GUIDE.md` - Configuration architecture and conventions
- `docs/REFACTORING_CONFIGS.md` - Configuration refactoring details
- `docs/REFACTORING_SUMMARY.md` - Overall refactoring summary and changes

### Development & Testing
- `docs/SHELL_SCRIPTING_BEST_PRACTICES_AND_LINTING_GUIDE.md` - Shell scripting standards
- `docs/SHELL_SCRIPT_TEST_RESULTS.md` - Test results and validation
- `docs/COMPREHENSIVE_SCRIPT_TESTING_REPORT.md` - Comprehensive testing documentation

### Project Management
- `docs/CONSOLIDATED_PR.md` - Pull request consolidation details
- `docs/FINAL_VERIFICATION.md` - Final verification and validation
- `docs/COMMIT_MESSAGES.md` - Commit message conventions
- `docs/progress.md` - Development progress tracking

## Key Architecture Patterns
- **Centralized Configuration**: All variables in `exports.sh`
- **Template + Custom Pattern**: Base configs + user customizations
- **Common Functions**: Shared utilities in `lib/common_functions.sh`
- **Client Diversity**: Support for 5 execution + 6 consensus clients

## Agent Guidelines
When working with this codebase:
1. Follow shell scripting best practices from `docs/SHELL_SCRIPTING_BEST_PRACTICES_AND_LINTING_GUIDE.md`
2. Maintain configuration consistency per `docs/CONFIGURATION_GUIDE.md`
3. Use common functions from `lib/common_functions.sh` to avoid duplication
4. Reference appropriate documentation for context and standards

## Common Functions Library
The `lib/common_functions.sh` contains 35 centralized functions for:
- **Logging**: `log_info()`, `log_warn()`, `log_error()`
- **Installation**: `log_installation_start()`, `log_installation_complete()`
- **Directory Management**: `get_script_directories()`, `ensure_directory()`, `create_temp_config_dir()`
- **Configuration**: `merge_client_config()` (supports JSON, YAML, TOML)
- **Security**: `setup_secure_user()`, `configure_ssh()`, `setup_fail2ban()`
- **System Services**: `create_systemd_service()`, `enable_and_start_systemd_service()`
- **File Operations**: `download_file()`, `secure_download()`
- **System Checks**: `check_system_requirements()`, `check_system_compatibility()`

## Refactoring Status
- ✅ **REFACTORING COMPLETE**: All 35 functions implemented and tested
- ✅ **Code Duplication**: Reduced by ~40% through centralized functions
- ✅ **Shellcheck Compliance**: 100% compliance achieved
- ✅ **Architecture**: Centralized configuration and function patterns maintained

## Code Review Process

### Required Review Passes (Minimum 3, Maximum 5)

**Pass 1: Functionality Verification**
- Verify all function calls work correctly
- Check for missing functions that are being called
- Ensure no broken function references
- Test that all added functions are properly defined

**Pass 2: Architecture Compliance** 
- Verify scripts run with correct user privileges (root vs non-root)
- Check that changes align with codebase architecture
- Ensure security functions are properly integrated
- Validate that client install scripts run as non-root users

**Pass 3: Code Quality**
- Remove duplicate functions
- Verify function signatures match usage
- Check for unused functions that can be removed
- Ensure consistent error handling patterns

**Pass 4: Edge Cases (if issues found in Pass 3)**
- Test critical paths and error conditions
- Verify all function parameters are handled correctly
- Check for any remaining hardcoded patterns

**Pass 5: Final Validation (if issues found in Pass 4)**
- Comprehensive end-to-end validation
- Final cleanup and documentation
- Verify all changes follow security best practices

### Review Completion Criteria
- All function calls work without errors
- No missing or broken function references
- Architecture compliance maintained (root vs non-root execution)
- Code quality standards met
- No functionality removed or broken

## Rule Enforcement Mechanisms

### Mandatory Compliance Checks
Before any code changes are considered complete, the following must be verified:

1. **Function Reference Validation**
   - All function calls must reference existing functions in `lib/common_functions.sh`
   - Use `grep` to verify function definitions exist before calling them
   - Replace any hardcoded patterns with centralized function calls

2. **Architecture Pattern Compliance**
   - Install scripts MUST call `require_root()` for privileged operations
   - Non-install scripts MUST NOT call `require_root()`
   - All scripts MUST call `get_script_directories()` for path management
   - Use `log_installation_start()` and `log_installation_complete()` for install scripts

3. **Security Function Integration**
   - Security functions MUST be called in `run_1.sh` for comprehensive setup
   - All configuration files MUST use `secure_config_files()` for proper permissions
   - Network security functions MUST be applied via `apply_network_security()`

4. **Code Quality Enforcement**
   - Run `shellcheck` on all modified scripts before committing
   - Remove any duplicate or unused functions
   - Ensure consistent error handling using `log_error()` and proper exit codes
   - Verify all function signatures match their usage patterns

### Validation Requirements

**Pre-Commit Validation Checklist:**
- [ ] All function calls verified to exist in `lib/common_functions.sh`
- [ ] Script execution privileges correctly implemented (root vs non-root)
- [ ] Security functions properly integrated where required
- [ ] Shellcheck compliance achieved (0 warnings/errors)
- [ ] No duplicate or unused functions remain
- [ ] Error handling patterns consistent across all modified files
- [ ] Documentation updated to reflect any new functions or changes

**Automated Validation Commands:**
```bash
# Verify function references
grep -r "function_name" install/ | grep -v "lib/common_functions.sh"

# Check shellcheck compliance
find install/ -name "*.sh" -exec shellcheck {} \;

# Verify root privilege usage
grep -r "require_root" install/ | wc -l  # Should match expected count
```

### Rule Violation Prevention

**Common Violations to Avoid:**
1. **Missing Function Calls** - Always verify functions exist before calling
2. **Incorrect Privilege Usage** - Install scripts need root, others don't
3. **Hardcoded Patterns** - Use centralized functions instead of duplicating code
4. **Inconsistent Error Handling** - Always use `log_error()` and proper exit codes
5. **Security Function Neglect** - Ensure security functions are properly integrated

**Enforcement Actions:**
- If any rule violation is detected, the code change MUST be rejected
- All violations MUST be fixed before proceeding to the next review pass
- Additional review passes MUST be performed until all rules are satisfied

## Consistency Maintenance Guidelines

### Code Pattern Standards
1. **Script Structure** - All scripts MUST follow the established pattern:
   ```bash
   #!/bin/bash
   source ../../exports.sh
   source ../../lib/common_functions.sh
   get_script_directories
   # [require_root for install scripts only]
   log_installation_start "ComponentName"
   # [script logic using common functions]
   log_installation_complete "ComponentName" "service_name"
   ```

2. **Function Usage** - Always prefer common functions over custom implementations:
   - Use `log_info()`, `log_warn()`, `log_error()` for all logging
   - Use `secure_download()` instead of `wget` or `curl` directly
   - Use `ensure_directory()` for directory creation
   - Use `create_systemd_service()` for service management

3. **Error Handling** - Consistent error handling pattern:
   ```bash
   if ! function_call; then
       log_error "Descriptive error message"
       exit 1
   fi
   ```

### Documentation Requirements
- All new functions MUST be documented in the appropriate section of this file
- Function usage examples MUST be provided in comments
- Architecture changes MUST be reflected in the relevant documentation files
- Security implications MUST be documented and validated

### Quality Assurance Process
1. **Before Making Changes** - Read and understand existing patterns
2. **During Development** - Follow established patterns and use common functions
3. **After Changes** - Run all validation checks and review passes
4. **Before Committing** - Ensure all rules are satisfied and documentation is updated

## MEV Implementation Guidelines

### Overview
This project supports TWO mutually exclusive MEV (Maximal Extractable Value) solutions:
- **MEV-Boost**: Industry-standard relay-based solution (RECOMMENDED)
- **Commit-Boost**: Modular sidecar that REPLACES MEV-Boost (experimental)

### MEV Implementation Architecture

**Key Principles:**
1. **Mutual Exclusivity**: Choose ONE - either MEV-Boost OR Commit-Boost, never both
2. **Binary Installation**: All MEV solutions installed as binaries (NO Docker)
3. **Consistency**: Follow same pattern as other client installations (git clone → build → systemd)
4. **Configuration Centralization**: All MEV variables in `exports.sh`
5. **Clear Guidance**: `run_2.sh` provides interactive MEV selection with recommendations

### MEV Configuration Standards

**Port Allocation:**
- MEV-Boost: Port 18550
- Commit-Boost: Port 18551 (PBS), 18552 (Signer), 18553 (Metrics)

**Configuration Variables (exports.sh):**
```bash
# Shared MEV settings
MEV_RELAYS='...'              # Comma-separated relay endpoints
MIN_BID=0.002                 # Minimum bid for block proposals
MEVGETHEADERT=950             # Timeout: getHeader (ms)
MEVGETPAYLOADT=4000           # Timeout: getPayload (ms)
MEVREGVALT=6000               # Timeout: registerValidator (ms)

# Commit-Boost specific (alternative to MEV-Boost)
COMMIT_BOOST_PORT=18551
COMMIT_BOOST_HOST='127.0.0.1'
```

### MEV Installation Script Patterns

**Required Elements:**
1. Download pre-built binaries OR build from source (NO Docker)
2. Extract binaries to installation directory
3. Firewall rules setup via `setup_firewall_rules()`
4. JWT secret verification via `ensure_jwt_secret()`
5. Configuration file generation with proper variable substitution
6. Systemd service creation via `create_systemd_service()`
7. Comprehensive status/verification output
8. Clear warning that solution replaces other MEV solutions (mutually exclusive)

**MEV-Boost Pattern:**
- Clone GitHub repository
- Build with `make build`
- Single binary execution
- Direct systemd service

**Commit-Boost Pattern:**
- Download pre-built binaries from GitHub releases
- Multiple binaries (pbs, signer)
- TOML configuration format
- Separate systemd services for each component
- MEV-Boost relay compatibility
- Support for additional protocols (preconfirmations, inclusion lists)

### MEV Testing Requirements

**Test Coverage:**
1. **Installation Tests**: Verify directories, binaries, services
2. **Configuration Tests**: Validate TOML/YAML/JSON syntax and content
3. **Service Tests**: Check systemd service status and enablement
4. **Docker Tests**: Verify container existence and health (for Commit-Boost/ETHGas)
5. **API Tests**: Test endpoint availability and responses
6. **Port Tests**: Verify no conflicts and proper bindings
7. **Firewall Tests**: Ensure UFW rules configured
8. **Dependency Tests**: Verify JWT secrets, Commit-Boost for ETHGas

**Testing Script Pattern:**
```bash
record_test() {
    local test_name="$1"
    local result="$2"  # PASS, FAIL, SKIP
    local details="$3"
    # Track results and display formatted output
}
```

### MEV Integration with Consensus Clients

**Configuration Updates:**
All consensus client base configs include MEV builder endpoint variables:
- Prysm: `http-mev-relay: http://$MEV_HOST:$MEV_PORT`
- Teku: `builder-endpoint: "http://$MEV_HOST:$MEV_PORT"`
- Lighthouse: CLI flag `--builder http://$MEV_HOST:$MEV_PORT`
- Lodestar: `builder.urls: ["http://$MEV_HOST:$MEV_PORT"]`
- Nimbus: `payload-builder-url = "http://$MEV_HOST:$MEV_PORT"`
- Grandine: `builder_endpoint = "http://$MEV_HOST:$MEV_PORT"`

**Builder Enablement:**
- Default: Builder disabled (`enable-builder: false` or equivalent)
- Users must manually enable after MEV solution is running
- Requires validator registration with fee recipient

### MEV Selection Pattern (run_2.sh)

**Interactive Selection:**
```bash
# Present MEV options with clear guidance
1. MEV-Boost (RECOMMENDED - stable, production-proven)
2. Commit-Boost (EXPERIMENTAL - for early adopters)
3. Skip (install later)

# IMPORTANT: Clearly state these are MUTUALLY EXCLUSIVE
# Provide descriptions of what each does
# Recommend MEV-Boost for most users
# Create install_mev_solution() function
# Provide clear user feedback and warnings
```

### MEV Documentation Standards

**Required Documentation Elements:**
1. **Overview**: What the MEV solution does and key features
2. **Installation**: Step-by-step installation process
3. **Configuration**: All configuration options and variables
4. **Service Management**: Start, stop, status, logs commands
5. **Verification**: How to verify the solution is working
6. **Integration**: How to integrate with consensus clients
7. **Troubleshooting**: Common issues and solutions
8. **Resources**: Links to official docs, repos, community

### MEV Security Considerations

**Security Best Practices:**
1. **JWT Authentication**: Always use JWT secrets for authenticated connections
2. **Firewall Rules**: Configure UFW for all MEV ports
3. **Local Binding**: Bind to 127.0.0.1 by default (not 0.0.0.0)
4. **Service Isolation**: Run services as non-root user
5. **Docker Security**: Use proper volume mounts and network isolation
6. **Credential Management**: Store sensitive data in `$HOME/secrets/`
7. **Collateral Monitoring**: For ETHGas, monitor collateral contract balances

### MEV Implementation Checklist

When implementing new MEV solutions:
- [ ] Create installation script in `install/mev/` following binary pattern
- [ ] Download pre-built binaries OR build from source (NO Docker)
- [ ] Add configuration variables to `exports.sh`
- [ ] Update `run_2.sh` with new MEV option
- [ ] Add clear warning that solutions are mutually exclusive
- [ ] Update test script to include new solution
- [ ] Update consensus client configurations (if needed)
- [ ] Add firewall rules via `setup_firewall_rules()`
- [ ] Ensure JWT secret handling via `ensure_jwt_secret()`
- [ ] Create systemd service via `create_systemd_service()`
- [ ] Document in MEV guides (`docs/MEV_*.md`)
- [ ] Perform 3-pass review (functionality, architecture, quality)
- [ ] Test integration with all consensus clients
- [ ] Verify NO Docker dependencies (maintain consistency)
- [ ] Include comprehensive status output and verification steps
- [ ] Provide recommendation guidance for users

### Lessons Learned from MEV Implementation

**Key Insights:**
1. **Consistency First**: NEVER introduce Docker if the project doesn't use it elsewhere
2. **Binary Installation**: Always check for pre-built binaries before considering Docker
3. **Mutual Exclusivity**: Make it crystal clear when solutions are mutually exclusive
4. **Recommendation Guidance**: Always recommend the stable, proven option (MEV-Boost)
5. **Port Management**: Reserve sequential ports for multi-component solutions
6. **Service Dependencies**: Use systemd Requires/After for service dependencies
7. **Testing Granularity**: Test at multiple levels (file, service, binary, API, integration)
8. **User Guidance**: Provide clear next steps, warnings, and verification commands
9. **Pattern Matching**: Follow existing installation patterns (git clone → build OR download → extract)
10. **Simplicity**: Remove experimental/niche features that break project consistency
11. **Configuration Clarity**: Use TOML for Rust, YAML for Java, maintain variable substitution
12. **Backward Compatibility**: Ensure new MEV options don't break existing MEV-Boost setups

## Testing Framework Guidelines

### Testing Approaches (In Order of Preference)

1. **Docker-Based Testing (RECOMMENDED for integration tests)**
   - Run tests inside isolated containers with REAL system calls
   - No risk to host system
   - Tests actual installation behavior
   - Use `docker-compose up --build test` from `test/` directory

2. **Local Testing with Mocks (for quick checks)**
   - Use mock functions to intercept system calls
   - Safe for local development
   - Run with `USE_MOCKS=true ./test/run_tests.sh`

3. **Lint-Only Testing (for CI)**
   - Shellcheck and syntax validation
   - No system calls needed
   - Run with `./test/run_tests.sh --lint-only`

### Testing File Structure
```
test/
├── Dockerfile           # Ubuntu container for isolated testing
├── docker-compose.yml   # Container orchestration
├── docker_test.sh       # Real system calls inside Docker
├── run_tests.sh         # Local test runner (supports mocks)
├── lib/
│   └── mock_functions.sh  # Mock implementations
└── results/             # Test output (gitignored)
```

### Critical Testing Rules

1. **Always use `|| true` for grep in pipelines** when using `set -Eeuo pipefail`
   - `grep` returns exit code 1 when no matches found
   - With `pipefail`, this causes script to exit
   - Fix: `grep pattern file | process || true`

2. **Mock functions must be sourced BEFORE the code under test**
   - Mocks override functions by redefining them
   - Order matters: source common_functions.sh, THEN mock_functions.sh

3. **Separate bash processes don't inherit mocks**
   - Running `bash script.sh` creates new process without mocks
   - Scripts that need mocks must source them internally
   - Use `USE_MOCKS` environment variable for conditional loading

4. **Test files should be self-contained**
   - Each test file should source its own dependencies
   - Don't rely on parent process having sourced files

### Lessons Learned from Testing Implementation

**Key Insights:**
1. **Docker over Mocks for Integration Tests**: Docker provides real system behavior without risk
2. **Mocks for Unit Tests Only**: Use mocks for quick, isolated function testing
3. **Pipefail Gotcha**: `set -Eeuo pipefail` + `grep` = potential silent failures
4. **Process Isolation**: Child bash processes don't inherit function overrides
5. **Test Independence**: Each test file must be runnable standalone
6. **Exit Code Verification**: Always check actual exit codes, not just output
7. **Clean Up After Tests**: Remove test artifacts (temp dirs, files)
8. **CI Exclusions**: Document why shellcheck rules are excluded (SC1090, SC1091, SC2031, etc.)

### Critical Path Resolution Rules for Test Scripts

**Problem:** CI dependency validators check sourced file paths relative to the script's directory, NOT from where `cd` commands move to. This causes false "file not found" errors.

**Anti-Pattern (NEVER DO THIS):**
```bash
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
cd "$PROJECT_ROOT"
source ./exports.sh  # ❌ CI resolves from $SCRIPT_DIR, not $PROJECT_ROOT
source ./lib/common_functions.sh  # ❌ Same problem
```

**Correct Pattern (ALWAYS DO THIS):**
```bash
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
cd "$PROJECT_ROOT"
# shellcheck source=../exports.sh
source "$PROJECT_ROOT/exports.sh"  # ✅ Absolute path works everywhere
# shellcheck source=../lib/common_functions.sh
source "$PROJECT_ROOT/lib/common_functions.sh"  # ✅ Absolute path
```

**Key Rules:**
1. **Always use `$PROJECT_ROOT` for source statements**, not relative paths
2. **Add `# shellcheck source=` directives** to help static analysis
3. **Use `$PROJECT_ROOT` for file existence checks** in tests
4. **Use `$PROJECT_ROOT` for running scripts**: `"$PROJECT_ROOT/install/script.sh"`

### Function Call Verification

**Problem:** With `set -Eeuo pipefail`, calling functions without required arguments causes silent crashes due to unbound variable errors.

**Anti-Pattern:**
```bash
ensure_jwt_secret  # ❌ Function requires $1 (path argument)
# Script silently exits with error
```

**Correct Pattern:**
```bash
jwt_file="$HOME/secrets/jwt.hex"
ensure_jwt_secret "$jwt_file"  # ✅ Pass required argument
```

**Key Rules:**
1. **Always check function signatures** in `lib/common_functions.sh` before calling
2. **Verify required vs optional parameters** - required params have no default (`$1`)
3. **Test function calls locally** before committing
4. **With `set -u`**, ALL positional parameters must be provided

### Test Output Format Verification

**Problem:** Tests may expect a different output format than what functions actually produce.

**Example:** `ensure_jwt_secret` uses `openssl rand -hex 32` which produces 64 hex chars WITHOUT `0x` prefix. Tests expecting 66 chars with `0x` will fail.

**Anti-Pattern:**
```bash
# Assuming format without checking
if [[ ${#jwt_content} -eq 66 ]] && [[ "$jwt_content" =~ ^0x ]]; then  # ❌ Wrong format
```

**Correct Pattern:**
```bash
# Match actual output format (64 hex chars, no prefix)
if [[ ${#jwt_content} -eq 64 ]] && [[ "$jwt_content" =~ ^[a-fA-F0-9]+$ ]]; then  # ✅
```

**Key Rules:**
1. **Inspect function implementation** before writing validation tests
2. **Test actual output** by running the function locally first
3. **Document expected formats** in comments
4. **Update tests when function behavior changes**

### Pre-Commit CI Simulation

**Always run these checks locally before pushing:**
```bash
# 1. Shellcheck all scripts
find . -name "*.sh" -type f ! -path "./.git/*" -exec shellcheck -x --exclude=SC2317,SC1091,SC1090,SC2034,SC2031 {} \;

# 2. Syntax validation
find . -name "*.sh" -type f ! -path "./.git/*" -exec bash -n {} \;

# 3. Dependency validation (simulates CI)
# Check that all 'source ./path' statements resolve correctly from script's directory

# 4. Function unit tests
bash install/test/test_common_functions.sh

# 5. Full lint tests
./test/run_tests.sh --lint-only
```

### Shellcheck CI Exclusions (with rationale)
```bash
# In .github/workflows/shellcheck.yml
--exclude=SC2317  # Unreachable code (false positive in test scripts)
--exclude=SC1091  # Not following source (relative paths)
--exclude=SC1090  # Non-constant source (variable paths)
--exclude=SC2034  # Unused variables (template scripts)
--exclude=SC2031  # Subshell variable modification (testing pattern)
```

## Code Reuse Guidelines

### DRY Principle Enforcement

**Rule: Never duplicate code that can be shared**

1. **Test Utilities** - All test scripts MUST source `test/lib/test_utils.sh`:
   ```bash
   SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
   LOG_PREFIX="CI"  # Optional: customize log prefix
   source "$SCRIPT_DIR/lib/test_utils.sh"
   ```

2. **Shellcheck Configuration** - Use centralized exclusions from `test_utils.sh`:
   ```bash
   # Use the shared function instead of inline shellcheck calls
   check_shellcheck "$script"  # Returns true/false
   run_shellcheck "$script"    # Shows output
   ```

3. **Common Functions** - All scripts MUST use `lib/common_functions.sh`:
   - Logging: `log_info`, `log_warn`, `log_error`
   - File ops: `ensure_directory`, `secure_download`, `extract_archive`
   - Services: `create_systemd_service`, `enable_and_start_systemd_service`
   - Security: `setup_secure_user`, `configure_ssh`, `ensure_jwt_secret`

### Centralized Dependency Management

**Single Source of Truth:** `install/utils/install_dependencies.sh`

This script supports multiple modes:
```bash
./install_dependencies.sh --test       # Minimal test dependencies
./install_dependencies.sh --base       # Base packages only  
./install_dependencies.sh --production # Full production (default)
```

**Package Groups (defined in script):**
- `BASE_PACKAGES` - Core utilities needed everywhere (curl, wget, git, jq, etc.)
- `TEST_PACKAGES` - Additional test tools (shellcheck, ufw, systemd)
- `PRODUCTION_PACKAGES` - Build tools, languages, services

**Docker Usage:**
```dockerfile
# In test/Dockerfile - uses centralized script
RUN /workspace/install/utils/install_dependencies.sh --test
```

**Key Features:**
- Detects Docker environment and skips incompatible tools (snap, timedatectl)
- Works as both root (Docker) and non-root (production)
- Provides `--help` to show all package groups

### Shared Test Utilities (`test/lib/test_utils.sh`)

Provides:
- `SHELLCHECK_EXCLUDES` - Centralized shellcheck configuration
- `LOG_PREFIX` - Customizable log prefix
- `log_info/warn/error/header` - Colored logging
- `record_test` / `print_test_summary` - Test result tracking
- `is_docker` / `is_root` - Environment detection
- `assert_file_exists` / `assert_command_exists` / `assert_valid_syntax` - Common assertions
- `source_exports` / `source_common_functions` - Proper project file sourcing
- `check_shellcheck` / `run_shellcheck` - Shellcheck with standard exclusions

### Anti-Patterns to Avoid

1. **Don't redefine colors in every script:**
   ```bash
   # BAD: Duplicates definition
   RED='\033[0;31m'
   GREEN='\033[0;32m'
   
   # GOOD: Source shared utilities
   source "$SCRIPT_DIR/lib/test_utils.sh"
   ```

2. **Don't hardcode shellcheck exclusions:**
   ```bash
   # BAD: Duplicates exclusion list
   shellcheck --exclude=SC2317,SC1091,SC1090... "$script"
   
   # GOOD: Use shared config
   check_shellcheck "$script"
   ```

3. **Don't duplicate logging functions:**
   ```bash
   # BAD: Redefines function
   log_info() { echo "[INFO] $1"; }
   
   # GOOD: Use from common_functions.sh or test_utils.sh
   source_common_functions
   ```

4. **Don't duplicate color definitions if sourcing common_functions.sh:**
   ```bash
   # BAD: Already defined in common_functions.sh
   RED='\033[0;31m'
   GREEN='\033[0;32m'
   
   # GOOD: Just use them (they're exported by common_functions.sh)
   # Colors available: RED, GREEN, YELLOW, BLUE, NC
   ```

### Standalone vs Integrated Scripts

**Standalone Scripts** (don't source common_functions.sh):
- `docs/server_security_validation.sh` - For running on production servers
- `docs/verify_security.sh` - Portable security verification
- `docs/validate_security_safe.sh` - Safe validation without root

These scripts intentionally duplicate colors/logging for portability - they should work when copied to any server without the full project.

**Integrated Scripts** (MUST source common_functions.sh):
- All `install/**/*.sh` scripts
- All `test/*.sh` scripts (via test_utils.sh or directly)
- `run_1.sh`, `run_2.sh`

### Code Consolidation Lessons Learned

1. **Create shared utility files early** - `test/lib/test_utils.sh` eliminated ~75 lines of duplicate code across 3 test files

2. **Add to common libraries proactively** - When adding a feature like BLUE color, add it to `common_functions.sh` so all scripts benefit

3. **Document intentional duplication** - Standalone scripts may need their own definitions; document why

4. **Use comments for removed code** - When removing duplicate definitions, leave a comment pointing to the source:
   ```bash
   # Colors are defined in common_functions.sh (RED, GREEN, YELLOW, BLUE, NC)
   ```

5. **Centralize configuration** - Shellcheck exclusions, test patterns, and other config should have a single source of truth

6. **Don't over-consolidate** - Some duplication is acceptable for:
   - Standalone/portable scripts
   - Scripts with specialized needs (run_tests.sh has CYAN, BOLD)
   - Generated scripts inside heredocs (aide_check.sh)

7. **Centralize environment-aware scripts** - Scripts like `install_dependencies.sh` should:
   - Detect their environment (Docker, root/non-root, snap availability)
   - Support multiple modes via flags (--test, --production)
   - Define package lists as arrays for easy modification
   - Skip incompatible operations gracefully with warnings

8. **Dockerfile should use project scripts** - Instead of duplicating package lists:
   ```dockerfile
   # BAD: Duplicates package list
   RUN apt-get install -y curl wget git shellcheck...
   
   # GOOD: Uses centralized script
   RUN /workspace/install/utils/install_dependencies.sh --test
   ```

This comprehensive rule set ensures consistent, maintainable, and secure code across the entire Ethereum node setup project.