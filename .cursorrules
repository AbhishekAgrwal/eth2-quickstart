# Ethereum Node Setup - Agent Context

## Documentation Structure
This project contains comprehensive documentation organized in the `docs/` folder:

### Core Documentation
- `docs/README.md` - Main project overview and quickstart guide
- `docs/SCRIPTS.md` - Detailed script reference and usage
- `docs/WORKFLOW.md` - Setup workflow and process documentation
- `docs/GLOSSARY.md` - Technical terminology and definitions

### Configuration & Architecture
- `docs/CONFIGURATION_GUIDE.md` - Configuration architecture and conventions
- `docs/REFACTORING_CONFIGS.md` - Configuration refactoring details
- `docs/REFACTORING_SUMMARY.md` - Overall refactoring summary and changes

### Development & Testing
- `docs/SHELL_SCRIPTING_BEST_PRACTICES_AND_LINTING_GUIDE.md` - Shell scripting standards
- `docs/SHELL_SCRIPT_TEST_RESULTS.md` - Test results and validation
- `docs/COMPREHENSIVE_SCRIPT_TESTING_REPORT.md` - Comprehensive testing documentation

### Project Management
- `docs/CONSOLIDATED_PR.md` - Pull request consolidation details
- `docs/FINAL_VERIFICATION.md` - Final verification and validation
- `docs/COMMIT_MESSAGES.md` - Commit message conventions
- `docs/progress.md` - Development progress tracking

## Key Architecture Patterns
- **Centralized Configuration**: All variables in `exports.sh`
- **Template + Custom Pattern**: Base configs + user customizations
- **Common Functions**: Shared utilities in `lib/common_functions.sh`
- **Client Diversity**: Support for 5 execution + 6 consensus clients

## Agent Guidelines
When working with this codebase:
1. Follow shell scripting best practices from `docs/SHELL_SCRIPTING_BEST_PRACTICES_AND_LINTING_GUIDE.md`
2. Maintain configuration consistency per `docs/CONFIGURATION_GUIDE.md`
3. Use common functions from `lib/common_functions.sh` to avoid duplication
4. Reference appropriate documentation for context and standards

## Common Functions Library
The `lib/common_functions.sh` contains 35 centralized functions for:
- **Logging**: `log_info()`, `log_warn()`, `log_error()`
- **Installation**: `log_installation_start()`, `log_installation_complete()`
- **Directory Management**: `get_script_directories()`, `ensure_directory()`, `create_temp_config_dir()`
- **Configuration**: `merge_client_config()` (supports JSON, YAML, TOML)
- **Security**: `setup_secure_user()`, `configure_ssh()`, `setup_fail2ban()`
- **System Services**: `create_systemd_service()`, `enable_and_start_systemd_service()`
- **File Operations**: `download_file()`, `secure_download()`
- **System Checks**: `check_system_requirements()`, `check_system_compatibility()`

## Refactoring Status
- ✅ **REFACTORING COMPLETE**: All 35 functions implemented and tested
- ✅ **Code Duplication**: Reduced by ~40% through centralized functions
- ✅ **Shellcheck Compliance**: 100% compliance achieved
- ✅ **Architecture**: Centralized configuration and function patterns maintained

## Code Review Process

### Required Review Passes (Minimum 3, Maximum 5)

**Pass 1: Functionality Verification**
- Verify all function calls work correctly
- Check for missing functions that are being called
- Ensure no broken function references
- Test that all added functions are properly defined

**Pass 2: Architecture Compliance** 
- Verify scripts run with correct user privileges (root vs non-root)
- Check that changes align with codebase architecture
- Ensure security functions are properly integrated
- Validate that client install scripts run as non-root users

**Pass 3: Code Quality**
- Remove duplicate functions
- Verify function signatures match usage
- Check for unused functions that can be removed
- Ensure consistent error handling patterns

**Pass 4: Edge Cases (if issues found in Pass 3)**
- Test critical paths and error conditions
- Verify all function parameters are handled correctly
- Check for any remaining hardcoded patterns

**Pass 5: Final Validation (if issues found in Pass 4)**
- Comprehensive end-to-end validation
- Final cleanup and documentation
- Verify all changes follow security best practices

### Review Completion Criteria
- All function calls work without errors
- No missing or broken function references
- Architecture compliance maintained (root vs non-root execution)
- Code quality standards met
- No functionality removed or broken

## Rule Enforcement Mechanisms

### Mandatory Compliance Checks
Before any code changes are considered complete, the following must be verified:

1. **Function Reference Validation**
   - All function calls must reference existing functions in `lib/common_functions.sh`
   - Use `grep` to verify function definitions exist before calling them
   - Replace any hardcoded patterns with centralized function calls

2. **Architecture Pattern Compliance**
   - Install scripts MUST call `require_root()` for privileged operations
   - Non-install scripts MUST NOT call `require_root()`
   - All scripts MUST call `get_script_directories()` for path management
   - Use `log_installation_start()` and `log_installation_complete()` for install scripts

3. **Security Function Integration**
   - Security functions MUST be called in `run_1.sh` for comprehensive setup
   - All configuration files MUST use `secure_config_files()` for proper permissions
   - Network security functions MUST be applied via `apply_network_security()`

4. **Code Quality Enforcement**
   - Run `shellcheck` on all modified scripts before committing
   - Remove any duplicate or unused functions
   - Ensure consistent error handling using `log_error()` and proper exit codes
   - Verify all function signatures match their usage patterns

### Validation Requirements

**Pre-Commit Validation Checklist:**
- [ ] All function calls verified to exist in `lib/common_functions.sh`
- [ ] Script execution privileges correctly implemented (root vs non-root)
- [ ] Security functions properly integrated where required
- [ ] Shellcheck compliance achieved (0 warnings/errors)
- [ ] No duplicate or unused functions remain
- [ ] Error handling patterns consistent across all modified files
- [ ] Documentation updated to reflect any new functions or changes

**Automated Validation Commands:**
```bash
# Verify function references
grep -r "function_name" install/ | grep -v "lib/common_functions.sh"

# Check shellcheck compliance
find install/ -name "*.sh" -exec shellcheck {} \;

# Verify root privilege usage
grep -r "require_root" install/ | wc -l  # Should match expected count
```

### Rule Violation Prevention

**Common Violations to Avoid:**
1. **Missing Function Calls** - Always verify functions exist before calling
2. **Incorrect Privilege Usage** - Install scripts need root, others don't
3. **Hardcoded Patterns** - Use centralized functions instead of duplicating code
4. **Inconsistent Error Handling** - Always use `log_error()` and proper exit codes
5. **Security Function Neglect** - Ensure security functions are properly integrated

**Enforcement Actions:**
- If any rule violation is detected, the code change MUST be rejected
- All violations MUST be fixed before proceeding to the next review pass
- Additional review passes MUST be performed until all rules are satisfied

## Consistency Maintenance Guidelines

### Code Pattern Standards
1. **Script Structure** - All scripts MUST follow the established pattern:
   ```bash
   #!/bin/bash
   source ../../exports.sh
   source ../../lib/common_functions.sh
   get_script_directories
   # [require_root for install scripts only]
   log_installation_start "ComponentName"
   # [script logic using common functions]
   log_installation_complete "ComponentName" "service_name"
   ```

2. **Function Usage** - Always prefer common functions over custom implementations:
   - Use `log_info()`, `log_warn()`, `log_error()` for all logging
   - Use `secure_download()` instead of `wget` or `curl` directly
   - Use `ensure_directory()` for directory creation
   - Use `create_systemd_service()` for service management

3. **Error Handling** - Consistent error handling pattern:
   ```bash
   if ! function_call; then
       log_error "Descriptive error message"
       exit 1
   fi
   ```

### Documentation Requirements
- All new functions MUST be documented in the appropriate section of this file
- Function usage examples MUST be provided in comments
- Architecture changes MUST be reflected in the relevant documentation files
- Security implications MUST be documented and validated

### Quality Assurance Process
1. **Before Making Changes** - Read and understand existing patterns
2. **During Development** - Follow established patterns and use common functions
3. **After Changes** - Run all validation checks and review passes
4. **Before Committing** - Ensure all rules are satisfied and documentation is updated

## MEV Implementation Guidelines

### Overview
This project supports TWO mutually exclusive MEV (Maximal Extractable Value) solutions:
- **MEV-Boost**: Industry-standard relay-based solution (RECOMMENDED)
- **Commit-Boost**: Modular sidecar that REPLACES MEV-Boost (experimental)

### MEV Implementation Architecture

**Key Principles:**
1. **Mutual Exclusivity**: Choose ONE - either MEV-Boost OR Commit-Boost, never both
2. **Binary Installation**: All MEV solutions installed as binaries (NO Docker)
3. **Consistency**: Follow same pattern as other client installations (git clone → build → systemd)
4. **Configuration Centralization**: All MEV variables in `exports.sh`
5. **Clear Guidance**: `run_2.sh` provides interactive MEV selection with recommendations

### MEV Configuration Standards

**Port Allocation:**
- MEV-Boost: Port 18550
- Commit-Boost: Port 18551 (PBS), 18552 (Signer), 18553 (Metrics)

**Configuration Variables (exports.sh):**
```bash
# Shared MEV settings
MEV_RELAYS='...'              # Comma-separated relay endpoints
MIN_BID=0.002                 # Minimum bid for block proposals
MEVGETHEADERT=950             # Timeout: getHeader (ms)
MEVGETPAYLOADT=4000           # Timeout: getPayload (ms)
MEVREGVALT=6000               # Timeout: registerValidator (ms)

# Commit-Boost specific (alternative to MEV-Boost)
COMMIT_BOOST_PORT=18551
COMMIT_BOOST_HOST='127.0.0.1'
```

### MEV Installation Script Patterns

**Required Elements:**
1. Download pre-built binaries OR build from source (NO Docker)
2. Extract binaries to installation directory
3. Firewall rules setup via `setup_firewall_rules()`
4. JWT secret verification via `ensure_jwt_secret()`
5. Configuration file generation with proper variable substitution
6. Systemd service creation via `create_systemd_service()`
7. Comprehensive status/verification output
8. Clear warning that solution replaces other MEV solutions (mutually exclusive)

**MEV-Boost Pattern:**
- Clone GitHub repository
- Build with `make build`
- Single binary execution
- Direct systemd service

**Commit-Boost Pattern:**
- Download pre-built binaries from GitHub releases
- Multiple binaries (pbs, signer)
- TOML configuration format
- Separate systemd services for each component
- MEV-Boost relay compatibility
- Support for additional protocols (preconfirmations, inclusion lists)

### MEV Testing Requirements

**Test Coverage:**
1. **Installation Tests**: Verify directories, binaries, services
2. **Configuration Tests**: Validate TOML/YAML/JSON syntax and content
3. **Service Tests**: Check systemd service status and enablement
4. **Docker Tests**: Verify container existence and health (for Commit-Boost/ETHGas)
5. **API Tests**: Test endpoint availability and responses
6. **Port Tests**: Verify no conflicts and proper bindings
7. **Firewall Tests**: Ensure UFW rules configured
8. **Dependency Tests**: Verify JWT secrets, Commit-Boost for ETHGas

**Testing Script Pattern:**
```bash
record_test() {
    local test_name="$1"
    local result="$2"  # PASS, FAIL, SKIP
    local details="$3"
    # Track results and display formatted output
}
```

### MEV Integration with Consensus Clients

**Configuration Updates:**
All consensus client base configs include MEV builder endpoint variables:
- Prysm: `http-mev-relay: http://$MEV_HOST:$MEV_PORT`
- Teku: `builder-endpoint: "http://$MEV_HOST:$MEV_PORT"`
- Lighthouse: CLI flag `--builder http://$MEV_HOST:$MEV_PORT`
- Lodestar: `builder.urls: ["http://$MEV_HOST:$MEV_PORT"]`
- Nimbus: `payload-builder-url = "http://$MEV_HOST:$MEV_PORT"`
- Grandine: `builder_endpoint = "http://$MEV_HOST:$MEV_PORT"`

**Builder Enablement:**
- Default: Builder disabled (`enable-builder: false` or equivalent)
- Users must manually enable after MEV solution is running
- Requires validator registration with fee recipient

### MEV Selection Pattern (run_2.sh)

**Interactive Selection:**
```bash
# Present MEV options with clear guidance
1. MEV-Boost (RECOMMENDED - stable, production-proven)
2. Commit-Boost (EXPERIMENTAL - for early adopters)
3. Skip (install later)

# IMPORTANT: Clearly state these are MUTUALLY EXCLUSIVE
# Provide descriptions of what each does
# Recommend MEV-Boost for most users
# Create install_mev_solution() function
# Provide clear user feedback and warnings
```

### MEV Documentation Standards

**Required Documentation Elements:**
1. **Overview**: What the MEV solution does and key features
2. **Installation**: Step-by-step installation process
3. **Configuration**: All configuration options and variables
4. **Service Management**: Start, stop, status, logs commands
5. **Verification**: How to verify the solution is working
6. **Integration**: How to integrate with consensus clients
7. **Troubleshooting**: Common issues and solutions
8. **Resources**: Links to official docs, repos, community

### MEV Security Considerations

**Security Best Practices:**
1. **JWT Authentication**: Always use JWT secrets for authenticated connections
2. **Firewall Rules**: Configure UFW for all MEV ports
3. **Local Binding**: Bind to 127.0.0.1 by default (not 0.0.0.0)
4. **Service Isolation**: Run services as non-root user
5. **Docker Security**: Use proper volume mounts and network isolation
6. **Credential Management**: Store sensitive data in `$HOME/secrets/`
7. **Collateral Monitoring**: For ETHGas, monitor collateral contract balances

### MEV Implementation Checklist

When implementing new MEV solutions:
- [ ] Create installation script in `install/mev/` following binary pattern
- [ ] Download pre-built binaries OR build from source (NO Docker)
- [ ] Add configuration variables to `exports.sh`
- [ ] Update `run_2.sh` with new MEV option
- [ ] Add clear warning that solutions are mutually exclusive
- [ ] Update test script to include new solution
- [ ] Update consensus client configurations (if needed)
- [ ] Add firewall rules via `setup_firewall_rules()`
- [ ] Ensure JWT secret handling via `ensure_jwt_secret()`
- [ ] Create systemd service via `create_systemd_service()`
- [ ] Document in MEV guides (`docs/MEV_*.md`)
- [ ] Perform 3-pass review (functionality, architecture, quality)
- [ ] Test integration with all consensus clients
- [ ] Verify NO Docker dependencies (maintain consistency)
- [ ] Include comprehensive status output and verification steps
- [ ] Provide recommendation guidance for users

### Lessons Learned from MEV Implementation

**Key Insights:**
1. **Consistency First**: NEVER introduce Docker if the project doesn't use it elsewhere
2. **Binary Installation**: Always check for pre-built binaries before considering Docker
3. **Mutual Exclusivity**: Make it crystal clear when solutions are mutually exclusive
4. **Recommendation Guidance**: Always recommend the stable, proven option (MEV-Boost)
5. **Port Management**: Reserve sequential ports for multi-component solutions
6. **Service Dependencies**: Use systemd Requires/After for service dependencies
7. **Testing Granularity**: Test at multiple levels (file, service, binary, API, integration)
8. **User Guidance**: Provide clear next steps, warnings, and verification commands
9. **Pattern Matching**: Follow existing installation patterns (git clone → build OR download → extract)
10. **Simplicity**: Remove experimental/niche features that break project consistency
11. **Configuration Clarity**: Use TOML for Rust, YAML for Java, maintain variable substitution
12. **Backward Compatibility**: Ensure new MEV options don't break existing MEV-Boost setups

This comprehensive rule set ensures consistent, maintainable, and secure code across the entire Ethereum node setup project.